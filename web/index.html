<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- fonts -->
    <link href="https://fonts.googleapis.com/css?family=Lato:700&display=swap" rel="stylesheet">

    <!-- bootstrap css -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.15.5/dist/bootstrap-table.min.css">

    <!-- locuszoom css -->
    <link rel="stylesheet" href="/static/locuszoom.css">

    <!-- title last -->
    <title>KPN Bio Index</title>

    <!-- don't show vue app until compiled, don't let alleles overflow -->
    <style>
        [v-cloak] {
            display: none;
        }
    </style>
</head>

<body>
    <center>
        <div id="app" v-cloak>
            <div class="mt-5 mb-2">
                <h1 style="font-family: 'Lato', sans-serif">KPN Bio-Index</h1>
            </div>

            <!-- locus input -->
            <div class="input-group mx-auto px-md-5 bg-white rounded w-50">
                <input v-model="locus" class="form-control" aria-describedby="locus" placeholder="gene or region"
                       @change="" type="text">
                <div class="input-group-append">
                    <button type="button" class="btn btn-primary mb-3"
                            @click="$store.dispatch('queryVariants', {locus})">
                        Query
                    </button>
                </div>
            </div>
            <div class="sm mb-4">Ex:
                <a href="#" @click="locus='SLC30A8'">SLC30A8</a>,
                <a href="#" @click="locus='chr9:21,940,000-22,190,000'">chr9:21,940,000-22,190,000</a>
            </div>

            <!-- match group -->
            <div class="btn-group mb-4" role="group" aria-label="Matches">
                <span class="btn btn-light btn-sm">Genes
                    <span v-if="hasGenes" class="badge badge-primary badge-pill">{{$store.state.geneCount}}</span>
                </span>
                <span class="btn btn-light btn-sm">Regions
                    <span v-if="hasRegions" class="badge badge-primary badge-pill">{{$store.state.regionCount}}</span>
                </span>
                <span class="btn btn-light btn-sm">Variants
                    <span v-if="hasVariants"
                        class=" badge badge-primary badge-pill">{{$store.state.variantCount}}</span>
                </span>
            </div>

            <div class="w-75">
                <div v-if="$store.state.loading">
                    <div class="spinner-border text-primary" role="status"></div>
                </div>

                <div v-show="dataLoaded" >
                    <div class="mb-4">
                        <button type="button" class="btn btn-sm m-1 py-1 px-2"
                                v-for="i in phenotypes.slice(0, 20)"
                                @click="$store.commit('setPhenotype', i[0])"
                                :class="{ 'btn-primary': i[0] == phenotype
                                        , 'btn-success': i[0] != phenotype && i[1] <= 5.0e-8
                                        , 'btn-warning': i[0] != phenotype && i[1] <= 0.05 && i[1] > 5.0e-8
                                        , 'btn-secondary': i[0] != phenotype && 0.05 < i[1]
                                        }"
                        >{{ i[0] }}</button>
                    </div>

                    <ul class="nav nav-tabs justify-content-center mb-3">
                        <li class="nav-item">
                            <a class="nav-link active" href="#">Associations</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#">PheWAS</a>
                        </li>
                    </ul>
                    <div id="locuszoom"></div>

                    <div>
                        <bootstrap-table id="table" :columns="tableColumns" :data="variants"
                            :options="{sortName:'pValue', ...tableOptions}"></bootstrap-table>
                    </div>
                </div>
            </div>
        </div>
    </center>

    <!-- jquery, popper, bootstrap -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script>

    <!-- vue.js -->
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <!--<script src="https://cdn.jsdelivr.net/npm/vue"></script>-->
    <script src="https://unpkg.com/vuex"></script>

    <!-- bootstrap table -->
    <script src="https://unpkg.com/bootstrap-table@1.15.5/dist/bootstrap-table.min.js"></script>
    <script src="https://unpkg.com/bootstrap-table@1.15.5/dist/bootstrap-table-vue.min.js"></script>

    <!-- d3 graphing and locuszoom -->
    <script src="/static/locuszoom.vendor.min.js"></script>
    <script src="/static/locuszoom.app.min.js"></script>

    <!-- vue app -->
    <script>
        Vue.use(BootstrapTable);

        let assocDataSource = LocusZoom.KnownDataSources.extend('StaticJSON', 'BioIndexAssocLZ', {
            getURL(state) {
                return `/api/query/variants?q=${state.chr}:${state.start}-${state.end}`;
            },

            annotateData(records) {
                records.forEach(r => {
                    r['id'] = r.varId;
                    r['log_pvalue'] = -Math.log10(r.pValue);
                    r['ref_allele'] = r.reference;
                    r['variant'] = r.alt;
                });

                return records;
            },
        });

        // SPA state
        let store = new Vuex.Store({
            state: {
                region: {},
                loading: false,
                phenotype: null,

                // how many estimated records per key space
                variantCount: 0,
                geneCount: 0,
                regionCount: 0,

                // records per key space
                variants: [],
            },
            mutations: {
                setLoading: (state, flag) => state.loading = flag,
                setRegion: (state, region) => state.region = region,
                setPhenotype: (state, phenotype) => state.phenotype = phenotype,

                // estimated counts
                setVariantCount: (state, n) => state.variantCount = n,
                setGeneCount: (state, n) => state.geneCount = n,
                setRegionCount: (state, n) => state.regionCount = n,

                // fetched records
                setVariants: (state, records) => state.variants = records,
            },
            actions: {
                // simple guess as to the number of records in the region
                async countVariants(context, { locus }) {
                    await count(context, 'setVariantCount', 'variants', locus);
                },
                async countGenes(context, { locus }) {
                    await count(context, 'setGeneCount', 'genes', locus);
                },
                async countRegions(context, { locus }) {
                    await count(context, 'setRegionCount', 'regions', locus);
                },

                // perform fetch queries to get the actual records
                async queryVariants({ commit }, { locus }) {
                    commit('setLoading', true);
                    commit('setVariants', []);

                    return fetch(`/api/query/variants?q=${encodeURIComponent(locus)}&sort=pValue`)
                        .then(resp => resp.json())
                        .then(json => {
                            commit('setLoading', false);
                            commit('setRegion', json.locus);
                            commit('setVariants', json.data);

                            if (json.data.length > 0) {
                                commit('setPhenotype', json.data[0].phenotype);
                            } else {
                                commit('setPhenotype', null);
                            }
                        })
                        .catch(err => {
                            commit('setLoading', false);
                        });
                },
            }
        });

        // entry point
        let app = new Vue({
            el: '#app',
            store,
            components: {
                'BootstrapTable': BootstrapTable,
            },
            data: {
                locus: '',
                tableOptions: {
                    pagination: true,
                    pageSize: 10,
                    search: true,
                    dataSortClass: 'table-active',
                },
                tableColumns: [
                    { title: 'Position', field: 'position', sortable: true },
                    { title: 'Ref', field: 'reference' },
                    { title: 'Alt', field: 'alt' },
                    { title: 'Phenotype', field: 'phenotype', sortable: true },
                    { title: 'P-Value', field: 'pValue', sortable: true },
                    { title: 'Effect', field: 'beta', sortable: true },
                    { title: 'Z-Score', field: 'zScore', sortable: true },
                    { title: 'StdErr', field: 'stdErr', sortable: true },
                    { title: 'N', field: 'n', sortable: true },
                ],
            },
            computed: {
                hasVariants() { return this.$store.state.variantCount > 0 },
                hasGenes() { return this.$store.state.geneCount > 0 },
                hasRegions() { return this.$store.state.regionCount > 0 },

                // true if there are loaded variants
                dataLoaded() { return this.$store.state.variants.length > 0 },

                // all the variants returned by the query
                variants() { return this.$store.state.variants },
                phenotype() { return this.$store.state.phenotype },

                // all the unique phenotypes in the region
                phenotypes() {
                    let ph = new Map();

                    // find all the unique phenotypes across all variants
                    this.$store.state.variants.forEach(v => {
                        if (!ph.has(v.phenotype)) {
                            ph.set(v.phenotype, v.pValue);
                        }
                    });

                    return Array.from(ph.entries());
                },
            },
            watch: {
                locus: debounce(function (locus) {
                    this.$store.dispatch('countVariants', { locus });
                    this.$store.dispatch('countGenes', { locus });
                    this.$store.dispatch('countRegions', { locus });
                }, 500),

                // update lz when variant data is updated
                variants(variants) {
                    this.updateLZ(variants, this.phenotype);
                },

                phenotype(phenotype) {
                    this.updateLZ(this.$store.state.variants, phenotype);
                },
            },
            methods: {
                updateLZ(variants, phenotype) {
                    let assocData = [];
                    let phewasData = [];

                    // filter and transform the variants into LZ format
                    variants.forEach(r => {
                        if (r.phenotype == phenotype) {
                            assocData.push({
                                id: r.varId,
                                position: r.position,
                                log_pvalue: -Math.log10(r.pValue),
                                ref_allele: r.reference,
                                variant: r.varId,
                            });
                        }
                    });

                    // create the phewas data from the variants
                    this.phenotypes.forEach(p => {
                        phewasData.push({
                            id: p[0],
                            trait_label: p[0],
                            trait_group: 'GLYCEMIC',
                            log_pvalue: -Math.log10(p[1]),
                        });
                    });

                    let ds = new LocusZoom.DataSources()
                        .add("assoc", ["StaticJSON", { data: assocData }])
                        .add("phewas", ["StaticJSON", { data: phewasData }])

                        // LD server
                        .add("ld", ["LDLZ2", {
                            url: "https://portaldev.sph.umich.edu/ld/",
                            params: {
                                source: '1000G',
                                build: 'GRCh37',
                                population: 'ALL',
                            },
                        }])

                        // recombinations
                        .add("recomb", ["RecombLZ", {
                            url: "https://portaldev.sph.umich.edu/api/v1/annotation/recomb/results/",
                            params: {
                                build: 'GRCh37',
                            },
                        }])

                        // genes
                        .add("gene", ["GeneLZ", {
                            url: "https://portaldev.sph.umich.edu/api/v1/annotation/genes/",
                            params: {
                                build: 'GRCh37',
                            },
                        }])

                        // gene constraints
                        .add("constraint", ["GeneConstraintLZ", {
                            url: "http://exac.broadinstitute.org/api/constraint",
                        }]);

                    let panelOptions = {
                        unnamespaced: true,
                        proportional_height: 0.5,
                        dashboard: null,
                    };

                    let panels = [
                        LocusZoom.Layouts.get('panel', 'association', { ...panelOptions }),
                        //LocusZoom.Layouts.get('panel', 'phewas', { ...panelOptions }),
                        LocusZoom.Layouts.get('panel', 'genes', { ...panelOptions }),
                    ];

                    let layout = LocusZoom.Layouts.get('plot', 'standard_association', {
                        panels,
                        state: {
                            chr: this.$store.state.region.chromosome,
                            start: this.$store.state.region.start,
                            end: this.$store.state.region.stop,
                        },
                    });

                    // update the plot with the data sources and layout
                    window.plot = LocusZoom.populate('#locuszoom', ds, layout);

                    // when scrolling a new data is requested, do something
                    window.plot.on('data_requested', () => {
                        let { chr, start, end } = window.plot.state;

                        // update the input and dispatch
                        this.locus = `${chr}:${start}-${end}`;
                        this.$store.dispatch('queryVariants', { locus: this.locus });
                    });
                }
            },
        });

        // request the estimated count for the number of records
        function count({ commit }, mutation, key, locus) {
            return fetch(`/api/count/${key}?q=${encodeURIComponent(locus)}`)
                .then(resp => resp.json())
                .then(json => commit(mutation, json.n))
                .catch(err => commit(mutation, 0));
        }

        // call function after a delay, overwrite any previous delay in place
        function debounce(f, wait, immediate) {
            let timeout = null;

            return function () {
                let context = this;
                let args = arguments;
                let callNow = immediate && !timeout;

                let later = function () {
                    timeout = null;
                    if (!immediate) {
                        f.apply(context, args);
                    }
                };

                clearTimeout(timeout);
                timeout = setTimeout(later, wait);

                if (callNow) {
                    f.apply(context, args);
                }
            };
        }
    </script>
</body>

</html>
